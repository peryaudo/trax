# Trax

## 短期目標

- [x] ランダムプレイヤーに80%以上勝利できる探索を今週中に -> できた(ほぼ100 percentile)
- [ ] SimpleSearcherをbaselineにして、これに80%以上勝てるものを作る

## 状況

SimpleSearcherが今のところ一番強いし爆速。

* ゲーム木へのPositionの割り振りとスコアリングは適切なのか
  * +kInf, -kInfは即詰みを意味するべきで、現状それ以外の物にもアサインされてる気がする
  * これが不適切だとするとLeafAverageEvaluatorがそこそこの評価関数なのはわりと納得？

/ について

\/と置けば

/\
\/になるから@1\と置く、というのは間違い

実際には

\/と置いたら

当然

\
\/されてしまう

これに沿ったスコアリングができているか？


* 評価関数につかえそうなもの
  * それを置いたことでの盤面のサイズ
    * Evidence: 探索空間を狭くするほうに誘導できるので探索速度が上がり有利になる
  * 埋まっているマス目の数
    * Evidence: 連鎖をより起こすものを置いたほうがよい？ or 置かないほうがよい？
  * 外接する辺のうち自分と同じ色の辺の数
    * Evidence: Victory Lineの作りやすさ

  * モンテカルロ
  * モンテカルロ木探索
  * 盤面を飲み込ませたCNN

## ToDo

* NegaMaxの2段目以上が弱い理由のデバッグ

* floodgate風レーティングをつけてくれるStartTournamentを実装

* Hash、縦横サイズを盛り込めば衝突マシになる？

* 255手で引き分けを入れる
* 秒数制限を守るのに使うような関数群をSearcherのベースクラス作ってそこに書いておく
  それでどのSearcherも共通ルーチン使ってできるように
  n回ループの内側きたらnanosec取得
  前回からの時間で次のnの値を調整
  0.8秒すぎたら店じまい
  clock_gettime(CLOCK_MONOTONIC)
* セットでNegaMaxに反復深化入れる
* マルチスレッド対応
* モンカル・UCT実装してみる
* 大会用デーモンで動くこと確認

* 反転と回転をHash()の引数でできるようにする
  * 反転も左右反転と色反転、手番反転などアリ

簡単なビット操作で回転と色反転をできる並べ方とかないか？

あと2次元配列を最短コードで回転させる方法




## ぼくのせんりゃく


ある方向から置くと連鎖させられてある方向から置くと連鎖させられないやつとかある

外側に向いてる自分の色の面とか評価関数にできるな

GPUはDeep Learning使わない限り使い所ないなあ

しかも肝心のモンテカルロ木探索はTrax向きではないみたいだし…

案外囲碁AIよりも将棋AIのアプローチを真似たほうがいいっぽい？

評価関数を作る場合囲碁とかリバーシってどういう特徴量を使ってるんだろう？Traxは案外使うべき特徴量というのは存在はするらしい(Threatの数)

そもそもいろんな意味でゲームの構成が分かってない

代替何手ぐらいでゲーム終了するのかとか

n手先までの状態数がどれくらいに膨れ上がるのかとか

このへんの特性が分からないと戦略の立てようがない

さらに、棋譜が全然手に入らないという特徴もある

わりとやねうら王みたいな感じでフレームワーク部を切り出して複数戦略書いて自己対戦させて…とかしたほうがいいのか…？

GPS将棋マンによるTrax評
http://www.slideshare.net/shogotakeuchi/ss-62415546

合法手が増えてくって言ってるけど、Traxも案外連鎖があるので一定？
というか、違う合法手に見えて実は本当に同じ手というのが存在しうる。
という作者の誤解がもしあれば、アルファベータ探索が案外いけるハズ。

この辺の数字間隔がつかめねえ〜

あとマスがでかくなってくのをどう管理すればいいかもどうZobrist Hashingすればいいかも分からないし

* MinMax探索型なのか
* MCTS型なのか
* あるいはこの2つを混ぜられるもんなのか

トーナメントをしてRを出すコードを書かないといけない…

Deep Learningで評価関数作ってMinMax案外正しい気もするけど確実に手で作れる評価関数以上のものをアレできる必要があるんだよな

制限時間1秒なる

GnuTraxは大体思いつく限りのナイーブなアルゴリズムが全部実装されててすごい。8x8Traxだけど………

https://github.com/MartinMSPedersen/GnuTrax/blob/master/src/org/traxgame/main/ComputerPlayerAlphaBeta.java

GnuTrax、CornersとThreatsの数をアルファベータの評価関数にしてるけど、序盤ではこの評価関数じゃ何も見えなさそうなのと、Threatsが全部リストアップされてるのがいただけない。
というかCornersとThreatsが分けられてるの自体がいただけない…

このThreats databaseとかcornersみたいなのをDeep Learningに感じ取ってほしい。（ムリでは………Deep Learningに多くを求めすぎでは………）

複数の起点から全く同じ連鎖を起こすことができる。一番左上のみを有効な手として扱って他をエイリアスとすることで、Moveを正規化できる。でもあんまり意味ないかも。

連鎖とかがあるせいで差分更新・ロールバックと、zobrist hashが使えないのが最大の問題。
→zobrist hashingに関しては別に置くコマを全部xorすれば問題ないじゃん。一番の問題は座標が定まらないほうであって、連鎖ではない。手順前後を正しくハッシュ化できることが一番重要
まあコピーを発生させまくるのでzobristはどのみち後回し。rollbackできないのは変わらないし………
正規化+連鎖でどこで止まったかとか記録すればロールバックもできる気がしてきたけど複雑すぎてコピーより軽くなる気しないな…


http://www.kitsunemimi.org/vsotha/algorithm.html
https://skatgame.net/mburo/ps/improve.pdf

リファレンス実装は毎回ボード（しかもmap!）コピーしてる…
でもボードサイズも変化するし毎回コピーする以外どうしようもなさある

どのみち毎回全コピーする場合は配列の拡張は問題にならない

小さいサイズについて特殊化してフォールバックするようにするとかしか思いつかん

FPGA的な話。一応そのうち考えとく。

http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=7377789&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D7377789
http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=1393254&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D1393254
http://link.springer.com/chapter/10.1007%2F978-3-540-69812-8_108#page-1

棋譜が無いわけではない

http://www.traxgame.com/games_archives.php

これの棋譜を与えて正しく表示されることを確認する。
http://www.traxgame.com/games_archives.php?pid=162

## 手候補・連鎖の判定

二次元boolで候補を持ってプログレッシブに更新できる？
効果薄かも

## 勝利の判定

### progressiveな場合には

今置いたピースがループかラインを構成していればいいので、再帰を使わず判定できる
それぞれ赤と白について。
速いかどうかは知らない。

### progressiveでない場合には

白または赤について、すべてのトラックについて番号付けする
［座］［標］［上下左右辺］ = 番号みたいな配列をつくってdfs

こっちもprogressiveに更新可能？ではないね。繋がる場合もある。

あとUnionFind木とかで管理できるかも


白または赤について、すべてのトラックについて番号付けする
== 全ての空でないマスの辺に番号をつける。

［座］［標］［上下左右辺］ = 番号みたいな配列をつくる

マスを見ていく
空でなくて
ある面が塗られていなかったら新しい番号をつけた上でFill()

あと、どこかに、その番号の持つ色を覚えておく

んでそれが終わったら〜Victory LineとLoopを判定する
Victory Line:
LeftとRight、あるいはTopとBottomで、外に接している辺のうちbboxにが乗っている物のなかで(めんどくさなんだこのルール！)で同じ番号がみつかったら、その色は勝ち
Loop:
その色について外接している辺がなければ、その色は勝ち

class WinnerChecker 

Fill(int x, int y, int previous_direction)




